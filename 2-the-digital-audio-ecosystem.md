# 第二章 数字音频的生态系统

要进行延迟补偿，必须先知道延迟有多少。本章展开描述了延迟的多种来源，以及获取与测量延迟的方式。

## 3 延迟的来源

### 3.1 声音在空气中的传播

由于声波是流体中的机械扰动，其传播速度较慢，约为 340m/s。这一点和延迟补偿的问题并不直接相关，但是前提条件在于麦克风和扬声器的正确安置。

然而需要注意的是，很多音乐家都学着习惯一个固定的延迟值。对于机械乐器（如管风琴）而言尤其如此，因为乐器本身的机制就会引入延迟。举例而言，从原声吉他或钢琴（乐器与人的距离约为 50cm）发出声音的延迟约为 1-2ms，这是由声波从乐器传播到人耳的时长决定的；管风琴可能需要一秒才会有反应。

对于安装多个扬声器阵列的大型场地而言，声速也很重要。此时必须添加适当的延迟处理，从而将多个扬声器的信号和舞台上的声音对齐。

### 3.2 D/A 和 A/D 转换

电信号传播迅速（约为光速），这时传播时间可以忽略不计，相较之下，模拟信号与数字信号的互转就需要较长时间。转换的延迟通常低于 1ms，在专业器件上更低。

### 3.3 计算机架构

延迟主要来源于处理循环。虽然每次循环处理的采样数通常由用户选择，但硬件、系统架构和音频驱动都会添加限制。

首先，循环时长（译者注：此处指每次循环处理的采样数）通常是 2 的整数次幂。这并不是硬性限制，而是 CPU 和总线接口的直接结果，因为地址空间是通过二进制管理的。选择非 2 的整数次幂作为循环时长通常无益，因为实际传输的分页数会向上取整至邻近的 2 的整数次幂。例如，传输 86 个采样的 CPU 负载和传输 128 个采样的负载相同，不过时限更小。

常见的消费级声卡（如 Intel HDA）会硬性采用每次循环 32 采样的较低限制，但是，即便如此设定，实际上声卡也无法可靠地对毫秒以下的数据块进行读写。每次循环 256 采样以上的值在消费级硬件上常见。虽然有块更小的专业设备，然而实际上，对于通用的计算机而言，每次 8 个采样一下就不现实了。

对于通用计算机而言，还有许多阻碍低延迟的因素。硬件而言主要和省电相关：例如，CPU 频率和总线频率的扩张（scale）会大幅影响最低响应时长。设计不佳的视频接口、WiFi 接口、USB 设备和设备驱动会长时间独占计算机的资源，使音频接口无法跟上数据流的传输。

大多数现代的机器带有系统管理和硬件健康检测的功能（SMI：系统管理中断），无法安全禁用。这些功能的执行也可能花上较长的时间。

### 3.4 操作系统

计算机必须遵循固定的时长间隔接收并传输音频数据，这一工作会涉及许多的子系统。

音频界扩会通过发送中断信号报告自身完成了数据获取或回放的循环。操作系统必须先接着执行目前活动的任务，直到能够处理中断信号为止。很多操作系统允许将任务优先处理，可以为特定的进程提供更快的响应时间。实时系统（如 Linux-rt）也允许抢占其他中断的处理，从而进一步降低处理优先中断的时长。

操作系统中，切换任务涉及进程上下文的切换，也会进一步引入延迟。上下文切换中既会引入确定的耗时（与 CPU 速度成线性），用于保存、恢复寄存器和栈的过程，也会引入可变的耗时，这一时长由触及的内存决定（TLB 刷新、缓存一致性）。每次上下文切换的影响大概在 10-100 微秒左右。

### 3.5 数字信号处理

很多音频处理算法的计算都需要上下文（即处理的采样前后的内容）。传入的音频信号存入缓冲区，当上下文足够时开始处理。这一操作实质上为传入的信号引入了延迟。

### 3.6 处理时间段

处理信号、添加多个效果以及合成由传入事件触发的声音都涉及对信号作数学运算，对于高性能机器而言可能都太苛刻。

多数 90 年代中期开始设计的 CPU 都带有 SIMD（单指令多数据）指令，可以高效对大块数据进行批量处理。最为熟知的就是 SSE（Streaming SIMD Extension）指令集，常见的后继指令集有 SSE2、SSE3、SSE4 和 AVX 等。对大量数据执行相同的运算时，SIMD 指令能大大提升性能，例如，依次处理 32 个采样要比处理一个采样 32 次快得多。

另一耗时因素则是由函数调用引入的开销。很多情况下，DSP 由多个无法内联的函数执行。尽管现代 CPU 上函数调用的开销在纳秒级，但处理小块的缓冲区时还是需要关注的。

块越大，处理块所需的总体 CPU 时间越少。

块的适宜大小由处理算法和性能与开销的考量决定。通常，缓冲区大小在每次循环 64 到 2048 个采样之间。

以上便是使用计算机时延迟的主要来源，不过可以预测，也能进行优化。